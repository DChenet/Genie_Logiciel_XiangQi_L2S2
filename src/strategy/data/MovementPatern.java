package strategy.data;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;

import tags.MovementTag;

/**
 * 
 * A movement patern is a set of moves a given piece can make in a given
 * situation. The movement tag associated to the set is used to label the
 * movement patern/give contextual informations, about what piece uses this
 * patern, when to use it etc... Movement paterns are generated by the
 * MovementPaternBuilder from sets of TaggedPath and stored into PieceModel
 * objects. From these piece models, we are able to create Piece objects to
 * which the movement paterns are transmitted.
 * 
 * During the game, the movement paterns stored in the piece objects are used to
 * generate the possible moves the piece can make. Possible moves are calculated
 * by the treatment classes RuleEvaluator which checks if a move is valid
 * according to the deplacement rules of the piece, then by the
 * MovementValidator which tells if a move is possible regarding the state of
 * the board / game.
 * 
 * @see MovementTag
 * @see TaggedPath
 * @see PieceModel
 * @see Piece
 * @see RuleEvaluator
 * @see MovementPatern
 * @author Dorian CHENET
 *
 */
public class MovementPatern {

	private MovementTag tag = new MovementTag();
	private ArrayList<LinkedList<Coordinates>> pathlist = new ArrayList<LinkedList<Coordinates>>();

	public MovementPatern() {
	}

	public MovementPatern(MovementTag tag, ArrayList<LinkedList<Coordinates>> movementlist) {
		this.pathlist = movementlist;
		this.tag = tag;
	}

	public void addMove(LinkedList<Coordinates> move) {
		if (!pathlist.contains(move)) {
			pathlist.add(move);
		}
	}

	public MovementTag getTag() {
		return tag;
	}

	public void setTag(MovementTag tag) {
		this.tag = tag;
	}

	public ArrayList<LinkedList<Coordinates>> getPathlist() {
		return pathlist;
	}

	public void setPathlist(ArrayList<LinkedList<Coordinates>> movementpatern) {
		this.pathlist = movementpatern;
	}

	@Override
	public String toString() {
		String str = "TAG=" + tag.toString() + "\n";
		int pathscount = 0;
		int positionscount = 0;

		Iterator<LinkedList<Coordinates>> arrayit = pathlist.iterator();
		LinkedList<Coordinates> path = null;

		while (arrayit.hasNext()) {
			path = arrayit.next();
			pathscount++;
			positionscount = 0;

			str += "Path " + pathscount + "\n";

			Coordinates coord = null;
			Iterator<Coordinates> pathit = path.iterator();

			while (pathit.hasNext()) {
				coord = pathit.next();
				positionscount++;

				str += "  " + coord.getX() + "," + coord.getY() + ">";

			}

			str += "\n Positions count = " + positionscount + "\n";

		}

		str += "Number of paths: " + pathscount + "\n";
		return str;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((pathlist == null) ? 0 : pathlist.hashCode());
		result = prime * result + ((tag == null) ? 0 : tag.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		MovementPatern other = (MovementPatern) obj;
		if (pathlist == null) {
			if (other.pathlist != null)
				return false;
		} else if (!pathlist.equals(other.pathlist))
			return false;
		if (tag == null) {
			if (other.tag != null)
				return false;
		} else if (!tag.equals(other.tag))
			return false;
		return true;
	}

}
